coords_all <- as.matrix(dt_year[, .(Lon, Lat)])
idx_targets <- which(dt_year$frac_area_SF > 0)
if (length(idx_targets) == 0) {
return(lapply(seq_along(radii_m), function(x) NULL))
}
# dividir alvos em blocos (para evitar sobrecarga de memória)
idx_split <- split(idx_targets, ceiling(seq_along(idx_targets)/chunk_size))
# listas intermediárias (uma lista por raio)
per_radius_chunks <- vector("list", length(radii_m))
names(per_radius_chunks) <- radii_labels
for (i in seq_along(per_radius_chunks)) per_radius_chunks[[i]] <- list()
# vetores de frações
v_PF <- dt_year$frac_area_PF
v_SF <- dt_year$frac_area_SF
v_Pa <- dt_year$frac_area_PA
v_Ag <- dt_year$frac_area_AG
# processar blocos
chunk_idx <- 1
for (ids in idx_split) {
coords_targets <- coords_all[ids, , drop = FALSE]
dist_mat <- distm(coords_targets, coords_all, fun = distHaversine)
base_chunk <- dt_year[ids, ..fixed_cols]
for (i in seq_along(radii_m)) {
r <- radii_m[i]
label <- radii_labels[i]
B <- dist_mat <= r
if (exclude_self) {
for (j in seq_len(nrow(B))) {
B[j, ids[j]] <- FALSE
}
}
counts <- rowSums(B)
counts[counts == 0] <- NA_real_
# converter matriz lógica para numérica antes da multiplicação
B_num <- B * 1
# somas ponderadas
sum_PF <- as.vector(B_num %*% v_PF)
sum_SF <- as.vector(B_num %*% v_SF)
sum_Pa <- as.vector(B_num %*% v_Pa)
sum_Ag <- as.vector(B_num %*% v_Ag)
mean_PF <- sum_PF / counts
mean_SF <- sum_SF / counts
mean_Pa <- sum_Pa / counts
mean_Ag <- sum_Ag / counts
dt_radius_chunk <- copy(base_chunk)
dt_radius_chunk[, paste0("mean_frac_area_PF_", label) := mean_PF]
dt_radius_chunk[, paste0("mean_frac_area_SF_", label) := mean_SF]
dt_radius_chunk[, paste0("mean_frac_area_PA_", label) := mean_Pa]
dt_radius_chunk[, paste0("mean_frac_area_AG_", label) := mean_Ag]
dt_radius_chunk[, paste0("n_neighbors_", label) := counts]
per_radius_chunks[[i]][[chunk_idx]] <- dt_radius_chunk
}
chunk_idx <- chunk_idx + 1
}
# juntar chunks por raio
per_radius_tables <- lapply(per_radius_chunks, function(lst) {
if (length(lst) == 0) return(NULL)
rbindlist(lst, use.names = TRUE, fill = TRUE)
})
return(per_radius_tables)
}
# ---------------------------------------------------------------------
# Loop principal por ano -> resultados separados por raio
# ---------------------------------------------------------------------
setkey(df_EBA_bruto, Ano)
anos <- sort(unique(df_EBA_bruto$Ano))
# estruturas para guardar resultados finais
result_1km <- list()
result_5km <- list()
result_10km <- list()
result_25km <- list()
result_50km <- list()
for (an in anos) {
message("Processando ano: ", an)
dt_year <- df_EBA_bruto[.(an)]
per_radius_for_year <- process_year_to_radius_tables(dt_year, chunk_size, exclude_self)
if (!is.null(per_radius_for_year[[1]])) result_1km[[as.character(an)]]  <- per_radius_for_year[[1]]
if (!is.null(per_radius_for_year[[2]])) result_5km[[as.character(an)]]  <- per_radius_for_year[[2]]
if (!is.null(per_radius_for_year[[3]])) result_10km[[as.character(an)]] <- per_radius_for_year[[3]]
if (!is.null(per_radius_for_year[[4]])) result_25km[[as.character(an)]] <- per_radius_for_year[[4]]
if (!is.null(per_radius_for_year[[5]])) result_50km[[as.character(an)]] <- per_radius_for_year[[5]]
}
# combinar todos os anos (um data.table final por raio)
result_1km  <- rbindlist(result_1km,  use.names = TRUE, fill = TRUE)
result_5km  <- rbindlist(result_5km,  use.names = TRUE, fill = TRUE)
result_10km <- rbindlist(result_10km, use.names = TRUE, fill = TRUE)
result_25km <- rbindlist(result_25km, use.names = TRUE, fill = TRUE)
result_50km <- rbindlist(result_50km, use.names = TRUE, fill = TRUE)
View(result_1km)
View(result_5km)
View(result_50km)
pixels_sf <- df_EBA_bruto %>%
group_by(Lon, Lat) %>%
summarize(has_SF = any(frac_area_SF == 1, na.rm = TRUE),
.groups = "drop") %>%
filter(has_SF)
View(pixels_sf)
##########################
library(dplyr)
df_selected <- df %>%
semi_join(pixels_sf, by = c("Lon", "Lat"))
df_selected <- df %>%
join(pixels_sf, by = c("Lon", "Lat"))
library(dplyr)
pixels_sf <- df_EBA_bruto %>%
group_by(Lon, Lat) %>%
summarize(has_SF = any(frac_area_SF == 1, na.rm = TRUE),
.groups = "drop") %>%
filter(has_SF)
df_selected <- df %>%
join(pixels_sf, by = c("Lon", "Lat"))
df_selected <- df_EBA_bruto %>%
join(pixels_sf, by = c("Lon", "Lat"))
library(dplyr)
pixels_sf <- df_EBA_bruto %>%
group_by(Lon, Lat) %>%
summarize(has_SF = any(frac_area_SF == 1, na.rm = TRUE),
.groups = "drop") %>%
filter(has_SF)
df_selected <- df_EBA_bruto %>%
join(pixels_sf, by = c("Lon", "Lat"))
class(df_EBA_bruto)
class(pixels_sf)
pixels_sf <- df_EBA_bruto %>%
group_by(Lon, Lat) %>%
summarize(has_SF = any(frac_area_SF == 1, na.rm = TRUE),
.groups = "drop") %>%
filter(has_SF)
df_selected <- df_EBA_bruto %>%
join(pixels_sf, by = c("Lon", "Lat"))
df_selected <- df_EBA_bruto %>%
semi_join(pixels_sf, by = c("Lon", "Lat"))
View(df_selected)
View(pixels_sf)
pixels_sf <- df_EBA_bruto %>%
group_by(Lon, Lat, Ano) %>%
summarize(has_SF = any(frac_area_SF == 1, na.rm = TRUE),
.groups = "drop") %>%
filter(has_SF)
View(pixels_sf)
df_selected <- df_EBA_bruto %>%
semi_join(pixels_sf, by = c("Lon", "Lat", "Ano"))
View(df_selected)
df_EBA_bruto <- df_selected
required_cols <- c("Lon","Lat","Ano",
"frac_area_PF","frac_area_SF","frac_area_PA","frac_area_AG",
"Prec","Evapo","Temp")
stopifnot(all(required_cols %in% names(df_EBA_bruto)))
# raios em metros e rótulos
radii_m <- c(1000, 5000, 10000, 25000, 50000)
radii_labels <- paste0(c(1,5,10,25,50), "km")
# parâmetros de processamento
chunk_size <- 2000
exclude_self <- FALSE
# colunas fixas
fixed_cols <- required_cols
# ---------------------------------------------------------------------
# Função que processa um ano e retorna uma lista de data.tables (um por raio)
# ---------------------------------------------------------------------
process_year_to_radius_tables <- function(dt_year, chunk_size, exclude_self) {
coords_all <- as.matrix(dt_year[, .(Lon, Lat)])
idx_targets <- which(dt_year$frac_area_SF > 0)
if (length(idx_targets) == 0) {
return(lapply(seq_along(radii_m), function(x) NULL))
}
# dividir alvos em blocos (para evitar sobrecarga de memória)
idx_split <- split(idx_targets, ceiling(seq_along(idx_targets)/chunk_size))
# listas intermediárias (uma lista por raio)
per_radius_chunks <- vector("list", length(radii_m))
names(per_radius_chunks) <- radii_labels
for (i in seq_along(per_radius_chunks)) per_radius_chunks[[i]] <- list()
# vetores de frações
v_PF <- dt_year$frac_area_PF
v_SF <- dt_year$frac_area_SF
v_Pa <- dt_year$frac_area_PA
v_Ag <- dt_year$frac_area_AG
# processar blocos
chunk_idx <- 1
for (ids in idx_split) {
coords_targets <- coords_all[ids, , drop = FALSE]
dist_mat <- distm(coords_targets, coords_all, fun = distHaversine)
base_chunk <- dt_year[ids, ..fixed_cols]
for (i in seq_along(radii_m)) {
r <- radii_m[i]
label <- radii_labels[i]
B <- dist_mat <= r
if (exclude_self) {
for (j in seq_len(nrow(B))) {
B[j, ids[j]] <- FALSE
}
}
counts <- rowSums(B)
counts[counts == 0] <- NA_real_
# converter matriz lógica para numérica antes da multiplicação
B_num <- B * 1
# somas ponderadas
sum_PF <- as.vector(B_num %*% v_PF)
sum_SF <- as.vector(B_num %*% v_SF)
sum_Pa <- as.vector(B_num %*% v_Pa)
sum_Ag <- as.vector(B_num %*% v_Ag)
mean_PF <- sum_PF / counts
mean_SF <- sum_SF / counts
mean_Pa <- sum_Pa / counts
mean_Ag <- sum_Ag / counts
dt_radius_chunk <- copy(base_chunk)
dt_radius_chunk[, paste0("mean_frac_area_PF_", label) := mean_PF]
dt_radius_chunk[, paste0("mean_frac_area_SF_", label) := mean_SF]
dt_radius_chunk[, paste0("mean_frac_area_PA_", label) := mean_Pa]
dt_radius_chunk[, paste0("mean_frac_area_AG_", label) := mean_Ag]
dt_radius_chunk[, paste0("n_neighbors_", label) := counts]
per_radius_chunks[[i]][[chunk_idx]] <- dt_radius_chunk
}
chunk_idx <- chunk_idx + 1
}
# juntar chunks por raio
per_radius_tables <- lapply(per_radius_chunks, function(lst) {
if (length(lst) == 0) return(NULL)
rbindlist(lst, use.names = TRUE, fill = TRUE)
})
return(per_radius_tables)
}
# ---------------------------------------------------------------------
# Loop principal por ano -> resultados separados por raio
# ---------------------------------------------------------------------
setkey(df_EBA_bruto, Ano)
anos <- sort(unique(df_EBA_bruto$Ano))
# estruturas para guardar resultados finais
result_1km <- list()
result_5km <- list()
result_10km <- list()
result_25km <- list()
result_50km <- list()
for (an in anos) {
message("Processando ano: ", an)
dt_year <- df_EBA_bruto[.(an)]
per_radius_for_year <- process_year_to_radius_tables(dt_year, chunk_size, exclude_self)
if (!is.null(per_radius_for_year[[1]])) result_1km[[as.character(an)]]  <- per_radius_for_year[[1]]
if (!is.null(per_radius_for_year[[2]])) result_5km[[as.character(an)]]  <- per_radius_for_year[[2]]
if (!is.null(per_radius_for_year[[3]])) result_10km[[as.character(an)]] <- per_radius_for_year[[3]]
if (!is.null(per_radius_for_year[[4]])) result_25km[[as.character(an)]] <- per_radius_for_year[[4]]
if (!is.null(per_radius_for_year[[5]])) result_50km[[as.character(an)]] <- per_radius_for_year[[5]]
}
# combinar todos os anos (um data.table final por raio)
result_1km  <- rbindlist(result_1km,  use.names = TRUE, fill = TRUE)
result_5km  <- rbindlist(result_5km,  use.names = TRUE, fill = TRUE)
result_10km <- rbindlist(result_10km, use.names = TRUE, fill = TRUE)
result_25km <- rbindlist(result_25km, use.names = TRUE, fill = TRUE)
result_50km <- rbindlist(result_50km, use.names = TRUE, fill = TRUE)
View(result_50km)
library(data.table)
library(geosphere)
EBA_bruto <- file.path("/media/amazonia/hd1/backup/paulo/dados_brutos/plan_LULC_Clima_2001-2021_EBA.csv")
df_EBA_bruto <- fread(EBA_bruto)
df_EBA_bruto <- as.data.table(df_EBA_bruto)
required_cols <- c("Lon","Lat","Ano",
"frac_area_PF","frac_area_SF","frac_area_PA","frac_area_AG",
"Prec","Evapo","Temp")
stopifnot(all(required_cols %in% names(df_EBA_bruto)))
# raios em metros e rótulos
radii_m <- c(1000, 5000, 10000, 25000, 50000)
radii_labels <- paste0(c(1,5,10,25,50), "km")
# parâmetros de processamento
chunk_size <- 2000
exclude_self <- FALSE
# colunas fixas
fixed_cols <- required_cols
# ---------------------------------------------------------------------
# Função que processa um ano e retorna uma lista de data.tables (um por raio)
# ---------------------------------------------------------------------
process_year_to_radius_tables <- function(dt_year, chunk_size, exclude_self) {
coords_all <- as.matrix(dt_year[, .(Lon, Lat)])
idx_targets <- which(dt_year$frac_area_SF > 0)
if (length(idx_targets) == 0) {
return(lapply(seq_along(radii_m), function(x) NULL))
}
# dividir alvos em blocos (para evitar sobrecarga de memória)
idx_split <- split(idx_targets, ceiling(seq_along(idx_targets)/chunk_size))
# listas intermediárias (uma lista por raio)
per_radius_chunks <- vector("list", length(radii_m))
names(per_radius_chunks) <- radii_labels
for (i in seq_along(per_radius_chunks)) per_radius_chunks[[i]] <- list()
# vetores de frações
v_PF <- dt_year$frac_area_PF
v_SF <- dt_year$frac_area_SF
v_Pa <- dt_year$frac_area_PA
v_Ag <- dt_year$frac_area_AG
# processar blocos
chunk_idx <- 1
for (ids in idx_split) {
coords_targets <- coords_all[ids, , drop = FALSE]
dist_mat <- distm(coords_targets, coords_all, fun = distHaversine)
base_chunk <- dt_year[ids, ..fixed_cols]
for (i in seq_along(radii_m)) {
r <- radii_m[i]
label <- radii_labels[i]
B <- dist_mat <= r
if (exclude_self) {
for (j in seq_len(nrow(B))) {
B[j, ids[j]] <- FALSE
}
}
counts <- rowSums(B)
counts[counts == 0] <- NA_real_
# converter matriz lógica para numérica antes da multiplicação
B_num <- B * 1
# somas ponderadas
sum_PF <- as.vector(B_num %*% v_PF)
sum_SF <- as.vector(B_num %*% v_SF)
sum_Pa <- as.vector(B_num %*% v_Pa)
sum_Ag <- as.vector(B_num %*% v_Ag)
mean_PF <- sum_PF / counts
mean_SF <- sum_SF / counts
mean_Pa <- sum_Pa / counts
mean_Ag <- sum_Ag / counts
dt_radius_chunk <- copy(base_chunk)
dt_radius_chunk[, paste0("mean_frac_area_PF_", label) := mean_PF]
dt_radius_chunk[, paste0("mean_frac_area_SF_", label) := mean_SF]
dt_radius_chunk[, paste0("mean_frac_area_PA_", label) := mean_Pa]
dt_radius_chunk[, paste0("mean_frac_area_AG_", label) := mean_Ag]
dt_radius_chunk[, paste0("n_neighbors_", label) := counts]
per_radius_chunks[[i]][[chunk_idx]] <- dt_radius_chunk
}
chunk_idx <- chunk_idx + 1
}
# juntar chunks por raio
per_radius_tables <- lapply(per_radius_chunks, function(lst) {
if (length(lst) == 0) return(NULL)
rbindlist(lst, use.names = TRUE, fill = TRUE)
})
return(per_radius_tables)
}
# ---------------------------------------------------------------------
# Loop principal por ano -> resultados separados por raio
# ---------------------------------------------------------------------
setkey(df_EBA_bruto, Ano)
anos <- sort(unique(df_EBA_bruto$Ano))
# estruturas para guardar resultados finais
result_1km <- list()
result_5km <- list()
result_10km <- list()
result_25km <- list()
result_50km <- list()
# parâmetros de processamento
chunk_size <- 3000
exclude_self <- TRUE
# colunas fixas
fixed_cols <- required_cols
# ---------------------------------------------------------------------
# Função que processa um ano e retorna uma lista de data.tables (um por raio)
# ---------------------------------------------------------------------
process_year_to_radius_tables <- function(dt_year, chunk_size, exclude_self) {
coords_all <- as.matrix(dt_year[, .(Lon, Lat)])
idx_targets <- which(dt_year$frac_area_SF > 0)
if (length(idx_targets) == 0) {
return(lapply(seq_along(radii_m), function(x) NULL))
}
# dividir alvos em blocos (para evitar sobrecarga de memória)
idx_split <- split(idx_targets, ceiling(seq_along(idx_targets)/chunk_size))
# listas intermediárias (uma lista por raio)
per_radius_chunks <- vector("list", length(radii_m))
names(per_radius_chunks) <- radii_labels
for (i in seq_along(per_radius_chunks)) per_radius_chunks[[i]] <- list()
# vetores de frações
v_PF <- dt_year$frac_area_PF
v_SF <- dt_year$frac_area_SF
v_Pa <- dt_year$frac_area_PA
v_Ag <- dt_year$frac_area_AG
# processar blocos
chunk_idx <- 1
for (ids in idx_split) {
coords_targets <- coords_all[ids, , drop = FALSE]
dist_mat <- distm(coords_targets, coords_all, fun = distHaversine)
base_chunk <- dt_year[ids, ..fixed_cols]
for (i in seq_along(radii_m)) {
r <- radii_m[i]
label <- radii_labels[i]
B <- dist_mat <= r
if (exclude_self) {
for (j in seq_len(nrow(B))) {
B[j, ids[j]] <- FALSE
}
}
counts <- rowSums(B)
counts[counts == 0] <- NA_real_
# converter matriz lógica para numérica antes da multiplicação
B_num <- B * 1
# somas ponderadas
sum_PF <- as.vector(B_num %*% v_PF)
sum_SF <- as.vector(B_num %*% v_SF)
sum_Pa <- as.vector(B_num %*% v_Pa)
sum_Ag <- as.vector(B_num %*% v_Ag)
mean_PF <- sum_PF / counts
mean_SF <- sum_SF / counts
mean_Pa <- sum_Pa / counts
mean_Ag <- sum_Ag / counts
dt_radius_chunk <- copy(base_chunk)
dt_radius_chunk[, paste0("mean_frac_area_PF_", label) := mean_PF]
dt_radius_chunk[, paste0("mean_frac_area_SF_", label) := mean_SF]
dt_radius_chunk[, paste0("mean_frac_area_PA_", label) := mean_Pa]
dt_radius_chunk[, paste0("mean_frac_area_AG_", label) := mean_Ag]
dt_radius_chunk[, paste0("n_neighbors_", label) := counts]
per_radius_chunks[[i]][[chunk_idx]] <- dt_radius_chunk
}
chunk_idx <- chunk_idx + 1
}
# juntar chunks por raio
per_radius_tables <- lapply(per_radius_chunks, function(lst) {
if (length(lst) == 0) return(NULL)
rbindlist(lst, use.names = TRUE, fill = TRUE)
})
return(per_radius_tables)
}
# ---------------------------------------------------------------------
# Loop principal por ano -> resultados separados por raio
# ---------------------------------------------------------------------
setkey(df_EBA_bruto, Ano)
anos <- sort(unique(df_EBA_bruto$Ano))
# estruturas para guardar resultados finais
result_1km <- list()
result_5km <- list()
result_10km <- list()
result_25km <- list()
result_50km <- list()
# parâmetros de processamento
chunk_size <- 4000
# ---------------------------------------------------------------------
# Função que processa um ano e retorna uma lista de data.tables (um por raio)
# ---------------------------------------------------------------------
process_year_to_radius_tables <- function(dt_year, chunk_size, exclude_self) {
coords_all <- as.matrix(dt_year[, .(Lon, Lat)])
idx_targets <- which(dt_year$frac_area_SF > 0)
if (length(idx_targets) == 0) {
return(lapply(seq_along(radii_m), function(x) NULL))
}
# dividir alvos em blocos (para evitar sobrecarga de memória)
idx_split <- split(idx_targets, ceiling(seq_along(idx_targets)/chunk_size))
# listas intermediárias (uma lista por raio)
per_radius_chunks <- vector("list", length(radii_m))
names(per_radius_chunks) <- radii_labels
for (i in seq_along(per_radius_chunks)) per_radius_chunks[[i]] <- list()
# vetores de frações
v_PF <- dt_year$frac_area_PF
v_SF <- dt_year$frac_area_SF
v_Pa <- dt_year$frac_area_PA
v_Ag <- dt_year$frac_area_AG
# processar blocos
chunk_idx <- 1
for (ids in idx_split) {
coords_targets <- coords_all[ids, , drop = FALSE]
dist_mat <- distm(coords_targets, coords_all, fun = distHaversine)
base_chunk <- dt_year[ids, ..fixed_cols]
for (i in seq_along(radii_m)) {
r <- radii_m[i]
label <- radii_labels[i]
B <- dist_mat <= r
if (exclude_self) {
for (j in seq_len(nrow(B))) {
B[j, ids[j]] <- FALSE
}
}
counts <- rowSums(B)
counts[counts == 0] <- NA_real_
# converter matriz lógica para numérica antes da multiplicação
B_num <- B * 1
# somas ponderadas
sum_PF <- as.vector(B_num %*% v_PF)
sum_SF <- as.vector(B_num %*% v_SF)
sum_Pa <- as.vector(B_num %*% v_Pa)
sum_Ag <- as.vector(B_num %*% v_Ag)
mean_PF <- sum_PF / counts
mean_SF <- sum_SF / counts
mean_Pa <- sum_Pa / counts
mean_Ag <- sum_Ag / counts
dt_radius_chunk <- copy(base_chunk)
dt_radius_chunk[, paste0("mean_frac_area_PF_", label) := mean_PF]
dt_radius_chunk[, paste0("mean_frac_area_SF_", label) := mean_SF]
dt_radius_chunk[, paste0("mean_frac_area_PA_", label) := mean_Pa]
dt_radius_chunk[, paste0("mean_frac_area_AG_", label) := mean_Ag]
dt_radius_chunk[, paste0("n_neighbors_", label) := counts]
per_radius_chunks[[i]][[chunk_idx]] <- dt_radius_chunk
}
chunk_idx <- chunk_idx + 1
}
# juntar chunks por raio
per_radius_tables <- lapply(per_radius_chunks, function(lst) {
if (length(lst) == 0) return(NULL)
rbindlist(lst, use.names = TRUE, fill = TRUE)
})
return(per_radius_tables)
}
# ---------------------------------------------------------------------
# Loop principal por ano -> resultados separados por raio
# ---------------------------------------------------------------------
setkey(df_EBA_bruto, Ano)
anos <- sort(unique(df_EBA_bruto$Ano))
# estruturas para guardar resultados finais
result_1km <- list()
result_5km <- list()
result_10km <- list()
result_25km <- list()
result_50km <- list()
for (an in anos) {
message("Processando ano: ", an)
dt_year <- df_EBA_bruto[.(an)]
per_radius_for_year <- process_year_to_radius_tables(dt_year, chunk_size, exclude_self)
if (!is.null(per_radius_for_year[[1]])) result_1km[[as.character(an)]]  <- per_radius_for_year[[1]]
if (!is.null(per_radius_for_year[[2]])) result_5km[[as.character(an)]]  <- per_radius_for_year[[2]]
if (!is.null(per_radius_for_year[[3]])) result_10km[[as.character(an)]] <- per_radius_for_year[[3]]
if (!is.null(per_radius_for_year[[4]])) result_25km[[as.character(an)]] <- per_radius_for_year[[4]]
if (!is.null(per_radius_for_year[[5]])) result_50km[[as.character(an)]] <- per_radius_for_year[[5]]
}
gc()
